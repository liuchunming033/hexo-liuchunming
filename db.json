{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/valine.css","path":"css/valine.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/click_show_text.js","path":"js/click_show_text.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"source/img/article/github-pages.png","path":"img/article/github-pages.png","modified":0,"renderable":0},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":0,"renderable":0},{"_id":"source/img/pay/wechat_pay.png","path":"img/pay/wechat_pay.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/pay/ali_pay.png","path":"img/pay/ali_pay.png","modified":0,"renderable":0},{"_id":"source/img/article/domain.jpeg","path":"img/article/domain.jpeg","modified":0,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":0,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":0,"renderable":0},{"_id":"source/img/article_header/bullon.jpg","path":"img/article_header/bullon.jpg","modified":0,"renderable":0},{"_id":"source/img/article/test-data-platform.png","path":"img/article/test-data-platform.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"873b3e9beb44827b59785fb5ae79b939e4aaa2f9","modified":1555309775203},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1555309775200},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1555318876788},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1555309775772},{"_id":"themes/huweihuang/_config.yml","hash":"a17a5aa9e9cbd9de97085ae94121e61b5b78c05e","modified":1555385992163},{"_id":"source/_posts/谈一谈软件测试中的测试数据准备.md","hash":"64b75addbd3689e431376c148f2a3425cf0f3695","modified":1555408467481},{"_id":"source/_posts/Hexo博客入门.md","hash":"c4c7fcfcd3cbcd2fe11f766a4bcefafc60cf8fc6","modified":1555385533712},{"_id":"source/about/index.md","hash":"75dc2546a7d49dd82bfcbb3b7a5015ab9865b91a","modified":1555310310542},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1555309775272},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1555309775769},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1555309775651},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1555309775781},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775784},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775788},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1555309775791},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1555309775794},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1555309775797},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1555309775800},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1555309775803},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1555309775808},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1555309775812},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1555309775862},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"b25c71964b3d2db93215df6b411f89bb948c5114","modified":1555309775865},{"_id":"themes/huweihuang/layout/index.ejs","hash":"559daffba672bedd15cd831d112a0dd53cb0576d","modified":1555309775868},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1555309775871},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"eb47421fce5c774c4ac5a6a0fe5b420b7c512a22","modified":1555309775875},{"_id":"themes/huweihuang/layout/post.ejs","hash":"db94e6e1565c252d8ed87964dacd1d788ce66f1a","modified":1555309775881},{"_id":"themes/huweihuang/layout/page.ejs","hash":"a93b28fe6650e5051fcee659411910bdd039e5dd","modified":1555309775878},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1555309775884},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1555309775323},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"9031412ba57d519bd8933f38f6b7f2581f64635e","modified":1555309775818},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"f19d731a5e35ba83801516cf522624d9a350eb66","modified":1555309775821},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"312f61ac8ba4cf0e672a8ad900376e335420ffd4","modified":1555309775825},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"f6f1ac0fbcb362546e37a35d6cb362f69fc5f0af","modified":1555309775828},{"_id":"themes/huweihuang/layout/_partial/comments.ejs","hash":"7f0986705157d0c6d24b12563d3810c1748fc0dd","modified":1555328289010},{"_id":"themes/huweihuang/layout/_partial/recommend_posts.ejs","hash":"0542f6c509e5119037465fdd91bc65bc18a96288","modified":1555309775834},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1555309775831},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1555309775837},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1555309775841},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1555309775849},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1555309775846},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1555309775853},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1555309775859},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1555309775887},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1555309775856},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1555309775891},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1555309775843},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1555309775996},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1555309776006},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1555309775898},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1555309776010},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1555309776061},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1555309776057},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1555309776064},{"_id":"themes/huweihuang/source/css/valine.css","hash":"f34d711b338412297fe0adb79353b792e053392c","modified":1555309776068},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1555309776074},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1555309776078},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1555309776189},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1555309776162},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1555309776216},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1555309776282},{"_id":"themes/huweihuang/source/js/click_show_text.js","hash":"f69402c056813cc30e98a4eaa27687807c307c48","modified":1555309776278},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1555309776252},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1555309776286},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1555309776377},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1555309776373},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1555309776384},{"_id":"themes/huweihuang/source/js/smoothscroll.js","hash":"134a1ad40b68efec27575a2cdd48eccf8a63bf71","modified":1555309776380},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1555309776387},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1555309775432},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1555309775959},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1555309776124},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1555309776242},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1555309776317},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1555309775462},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1555309775490},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1555309775743},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1555309776018},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1555309776051},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1555309775907},{"_id":"source/img/article/github-pages.png","hash":"6d640742e3d0377bda56c1920b36f120e137362a","modified":1555385533833},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1555309775370},{"_id":"source/img/pay/wechat_pay.png","hash":"1503eb2c9206aac256787b1bed84f9c3452e0a4d","modified":1555309775687},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1555309775716},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1555309776291},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1555309775331},{"_id":"source/img/pay/ali_pay.png","hash":"15b04dda349b629e4c996a3390a2e620c4d5b269","modified":1555309775658},{"_id":"source/img/article/domain.jpeg","hash":"07cdfcd896dfad648b5526af5f5b3b9eb3150665","modified":1555385533742},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1555309775280},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1555309775558},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1555309775628},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555309775361},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1555309775526},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1555309775595},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1555309775407},{"_id":"source/img/.DS_Store","hash":"8671de045093e927b9c0fcc13d80546a758491dd","modified":1555402593422},{"_id":"source/img/article_header/bullon.jpg","hash":"441949032a38812af1f1ae25f815c04494fcf459","modified":1555402577496},{"_id":"source/img/article/test-data-platform.png","hash":"5655aec4463fecfd38c3f97bf027d4a17959f00d","modified":1555400517411}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-04-15T06:29:35.200Z","updated":"2019-04-15T06:29:35.200Z","path":"404.html","title":"","comments":1,"_id":"cjujdfyv10000929v733ke9ze","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2019-04-15T02:48:33.000Z","description":"走在成为极客的路上","header-img":"/img/header_img/about.jpg","aplayer":false,"fixed":false,"_content":"\n### 一句话\n\n>Just do it !    (翻译：我只是个搞 IT的！哭笑脸)\n\n### 关于我\n\n>一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，\n>\n>偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！\n\n### 兴趣方向\n\n> 容器云（Docker、Kubernetes等）相关生态技术研究。\n\n### 参与社区\n\n > CSDN博客:httsp://blog.csdn.et/liuchunming033\n >\n > Github:https://github.com/liuchunming033\n >\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2019-04-15 10:48:33\ndescription: \"走在成为极客的路上\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false \nfixed: false\n---\n\n### 一句话\n\n>Just do it !    (翻译：我只是个搞 IT的！哭笑脸)\n\n### 关于我\n\n>一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，\n>\n>偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！\n\n### 兴趣方向\n\n> 容器云（Docker、Kubernetes等）相关生态技术研究。\n\n### 参与社区\n\n > CSDN博客:httsp://blog.csdn.et/liuchunming033\n >\n > Github:https://github.com/liuchunming033\n >\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n","updated":"2019-04-15T06:38:30.542Z","path":"about/index.html","comments":1,"_id":"cjujdfyx20002929vfzqi5hs4","content":"<h3 id=\"一句话\">一句话</h3>\n<blockquote>\n<p>Just do it !    (翻译：我只是个搞 IT的！哭笑脸)</p>\n</blockquote>\n<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，</p>\n<p>偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！</p>\n</blockquote>\n<h3 id=\"兴趣方向\">兴趣方向</h3>\n<blockquote>\n<p>容器云（Docker、Kubernetes等）相关生态技术研究。</p>\n</blockquote>\n<h3 id=\"参与社区\">参与社区</h3>\n<blockquote>\n<p>CSDN博客:httsp://blog.csdn.et/liuchunming033</p>\n<p>Github:<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>Just do it !    (翻译：我只是个搞 IT的！哭笑脸)</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，</p>\n<p>偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>容器云（Docker、Kubernetes等）相关生态技术研究。</p>\n</blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>CSDN博客:httsp://blog.csdn.et/liuchunming033</p>\n<p>Github:<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-04-15T06:29:35.272Z","path":"archive/index.html","_id":"cjujdfyxp0006929vby79rswd","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-04-15T06:29:35.769Z","updated":"2019-04-15T06:29:35.769Z","path":"tags/index.html","comments":1,"_id":"cjujdfyxq0007929vc21jhr35","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"谈一谈软件测试中的测试数据准备","catalog":true,"toc_nav_num":true,"date":"2019-04-16T11:51:24.000Z","subtitle":"测试数据准备方法以及未来的发展方向","header-img":"/img/article_header/balloon.jpg","catagories":["软件测试"],"_content":"\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据生成平台\"既可以封装业务接口提供基于业务场景的真实数据，也可以整个Mock框架解决服务间依赖问题。我们还可以引入一个内部数据库，用来存放生成的测试数据以及元数据，来记录测试数据使用者、测试数据创建时间等，用于对测试数据的进一步管理。有了统一测试数据平台，我们还可以做很多扩展性的功能对测试数据进行维护，大大方便了测试工作。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，介绍如何从0搭建统一测试数据平台。","source":"_posts/谈一谈软件测试中的测试数据准备.md","raw":"---\ntitle: \"谈一谈软件测试中的测试数据准备\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-16 19:51:24\nsubtitle: \"测试数据准备方法以及未来的发展方向\"\nheader-img: \"/img/article_header/balloon.jpg\"\ntags:\n- 软件测试\ncatagories:\n- 软件测试\n---\n\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据生成平台\"既可以封装业务接口提供基于业务场景的真实数据，也可以整个Mock框架解决服务间依赖问题。我们还可以引入一个内部数据库，用来存放生成的测试数据以及元数据，来记录测试数据使用者、测试数据创建时间等，用于对测试数据的进一步管理。有了统一测试数据平台，我们还可以做很多扩展性的功能对测试数据进行维护，大大方便了测试工作。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，介绍如何从0搭建统一测试数据平台。","slug":"谈一谈软件测试中的测试数据准备","published":1,"updated":"2019-04-16T09:54:27.481Z","_id":"cjujdfywy0001929vrn5alvoh","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2 id=\"常见的测试数据准备方法\">常见的测试数据准备方法</h2>\n<p>我总了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3 id=\"基于gui准备测试数据\">基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3 id=\"基于api准备测试数据\">基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3 id=\"基于db准备测试数据\">基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3 id=\"基于mq准备测试数据\">基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3 id=\"基于第三方库准备测试数据\">基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3 id=\"综合运用上述方法准备测试数据\">综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2 id=\"准备测试数据的时机\">准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3 id=\"实时创建on-the-fly\">实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3 id=\"提前准备out-of-box\">提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2 id=\"构造测试数据的痛点及应对\">构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3 id=\"调用封装函数的复杂性\">调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3 id=\"封装函数的版本管理\">封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2 id=\"统一测试数据生成平台\">统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据生成平台&quot;既可以封装业务接口提供基于业务场景的真实数据，也可以整个Mock框架解决服务间依赖问题。我们还可以引入一个内部数据库，用来存放生成的测试数据以及元数据，来记录测试数据使用者、测试数据创建时间等，用于对测试数据的进一步管理。有了统一测试数据平台，我们还可以做很多扩展性的功能对测试数据进行维护，大大方便了测试工作。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，介绍如何从0搭建统一测试数据平台。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2>常见的测试数据准备方法</h2>\n<p>我总了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3>基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3>基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3>基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3>基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3>基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3>综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2>准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3>实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3>提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2>构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3>调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3>封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2>统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据生成平台&quot;既可以封装业务接口提供基于业务场景的真实数据，也可以整个Mock框架解决服务间依赖问题。我们还可以引入一个内部数据库，用来存放生成的测试数据以及元数据，来记录测试数据使用者、测试数据创建时间等，用于对测试数据的进一步管理。有了统一测试数据平台，我们还可以做很多扩展性的功能对测试数据进行维护，大大方便了测试工作。</p>\n<h2>总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，介绍如何从0搭建统一测试数据平台。</p>\n"},{"title":"Hexo博客入门","catalog":true,"toc_nav_num":true,"date":"2019-04-15T02:51:24.000Z","subtitle":"从0开始搭建Hexo博客","header-img":"/img/article_header/article_header.png","top":9,"catagories":["Hexo"],"_content":"\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","source":"_posts/Hexo博客入门.md","raw":"---\ntitle: \"Hexo博客入门\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-15 10:51:24\nsubtitle: \"从0开始搭建Hexo博客\"\nheader-img: \"/img/article_header/article_header.png\"\ntop: 9\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","slug":"Hexo博客入门","published":1,"updated":"2019-04-16T03:32:13.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjujdfyx30003929vxrxcx3z6","content":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2 id=\"安装hexo\">安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速启动一个博客\">快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2 id=\"创建一篇自己的博文\">创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2 id=\"让更多人看到你的博客\">让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3 id=\"新建github仓库\">新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3 id=\"设置部署选项\">设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3 id=\"部署博客站点到github\">部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3 id=\"配置https和自定义域名\">配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2 id=\"个性化主题\">个性化主题</h2>\n<h3 id=\"更换主题模板\">更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3 id=\"边栏设置\">边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3 id=\"评论区设置\">评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3 id=\"相关文章设置\">相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2>安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2>快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2>创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2>让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3>新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3>设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3>部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3>配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2>个性化主题</h2>\n<h3>更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3>边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3>评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3>相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjujdfyx30003929vxrxcx3z6","tag_id":"cjujdfyx60004929v5ropue4g","_id":"cjujdfyx90005929v3jmhnaca"},{"post_id":"cjujdfywy0001929vrn5alvoh","tag_id":"cjujdksmn0008929v4tszklry","_id":"cjujdksmo0009929vpv2rdnu2"}],"Tag":[{"name":"Hexo","_id":"cjujdfyx60004929v5ropue4g"},{"name":"软件测试","_id":"cjujdksmn0008929v4tszklry"}]}}