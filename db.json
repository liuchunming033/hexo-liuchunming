{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/valine.css","path":"css/valine.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/click_show_text.js","path":"js/click_show_text.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/earch.jpg","path":"img/header_img/earch.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tizi.jpg","path":"img/header_img/tizi.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"source/img/article_header/bullon.jpg","path":"img/article_header/bullon.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/computer.jpg","path":"img/header_img/computer.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/xirikui.jpg","path":"img/header_img/xirikui.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/article/github-pages.png","path":"img/article/github-pages.png","modified":0,"renderable":0},{"_id":"source/img/pay/wechat_pay.png","path":"img/pay/wechat_pay.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":0,"renderable":0},{"_id":"source/img/header_img/moutain.jpg","path":"img/header_img/moutain.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/pencil.jpg","path":"img/header_img/pencil.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/road2.jpg","path":"img/header_img/road2.jpg","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/pay/ali_pay.png","path":"img/pay/ali_pay.png","modified":0,"renderable":0},{"_id":"source/img/article/test-data-platform.png","path":"img/article/test-data-platform.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/road.jpg","path":"img/header_img/road.jpg","modified":0,"renderable":0},{"_id":"source/img/article/domain.jpeg","path":"img/article/domain.jpeg","modified":0,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":0,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1555309775200},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1555318876788},{"_id":"source/CNAME","hash":"873b3e9beb44827b59785fb5ae79b939e4aaa2f9","modified":1555309775203},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1555309775772},{"_id":"themes/huweihuang/_config.yml","hash":"a17a5aa9e9cbd9de97085ae94121e61b5b78c05e","modified":1555385992163},{"_id":"source/_posts/软件自动化测试中的测试环境演进之路.md","hash":"3ebb020fa5051e2e229030bda54b28b923a3f2b0","modified":1555576936697},{"_id":"source/_posts/如何定制和管理自动化测试中的测试报告.md","hash":"2fb26b7eae936a352b2fc0df1f80984e282e46fa","modified":1555576936685},{"_id":"source/_posts/Hexo博客入门.md","hash":"c4c7fcfcd3cbcd2fe11f766a4bcefafc60cf8fc6","modified":1555385533712},{"_id":"source/about/index.md","hash":"0a9adcd0af1859688331e5b7be0395a49f39bd51","modified":1555571038200},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1555309775272},{"_id":"source/_posts/谈一谈软件测试中的测试数据准备.md","hash":"64379420b7a20b7dac61b78c4b16b7ae0297a740","modified":1555571070948},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1555309775651},{"_id":"source/img/.DS_Store","hash":"8671de045093e927b9c0fcc13d80546a758491dd","modified":1555402593422},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1555309775769},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1555309775781},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775784},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1555309775791},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775788},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1555309775794},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1555309775797},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1555309775803},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1555309775800},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1555309775808},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1555309775812},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1555309775862},{"_id":"themes/huweihuang/layout/index.ejs","hash":"559daffba672bedd15cd831d112a0dd53cb0576d","modified":1555309775868},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"b25c71964b3d2db93215df6b411f89bb948c5114","modified":1555309775865},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"eb47421fce5c774c4ac5a6a0fe5b420b7c512a22","modified":1555309775875},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1555309775871},{"_id":"themes/huweihuang/layout/page.ejs","hash":"a93b28fe6650e5051fcee659411910bdd039e5dd","modified":1555309775878},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1555309775884},{"_id":"themes/huweihuang/layout/post.ejs","hash":"db94e6e1565c252d8ed87964dacd1d788ce66f1a","modified":1555309775881},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1555309775323},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"f19d731a5e35ba83801516cf522624d9a350eb66","modified":1555309775821},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"9031412ba57d519bd8933f38f6b7f2581f64635e","modified":1555309775818},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"312f61ac8ba4cf0e672a8ad900376e335420ffd4","modified":1555309775825},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"f6f1ac0fbcb362546e37a35d6cb362f69fc5f0af","modified":1555309775828},{"_id":"themes/huweihuang/layout/_partial/recommend_posts.ejs","hash":"0542f6c509e5119037465fdd91bc65bc18a96288","modified":1555309775834},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1555309775841},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1555309775831},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1555309775837},{"_id":"themes/huweihuang/layout/_partial/comments.ejs","hash":"7f0986705157d0c6d24b12563d3810c1748fc0dd","modified":1555328289010},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1555309775843},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1555309775846},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1555309775849},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1555309775853},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1555309775856},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1555309775859},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1555309775887},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1555309775891},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1555309775898},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1555309775996},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1555309776006},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1555309776010},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1555309776057},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1555309776061},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1555309776064},{"_id":"themes/huweihuang/source/css/valine.css","hash":"f34d711b338412297fe0adb79353b792e053392c","modified":1555309776068},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1555309776074},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1555309776282},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1555309776252},{"_id":"themes/huweihuang/source/js/click_show_text.js","hash":"f69402c056813cc30e98a4eaa27687807c307c48","modified":1555309776278},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1555309776286},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1555309776373},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1555309776377},{"_id":"themes/huweihuang/source/js/smoothscroll.js","hash":"134a1ad40b68efec27575a2cdd48eccf8a63bf71","modified":1555309776380},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1555309776384},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1555309776387},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1555309776078},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1555309776189},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1555309776162},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1555309776216},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1555309775432},{"_id":"source/img/header_img/earch.jpg","hash":"7baa2660db94e294dff0ff020a40362a347955fb","modified":1555416138476},{"_id":"source/img/header_img/tizi.jpg","hash":"4309e0c07f58d0378f0eea20cbe6b8e73885add8","modified":1555416123312},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1555309775959},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1555309776242},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1555309776317},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1555309776124},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1555309775743},{"_id":"source/img/article_header/bullon.jpg","hash":"441949032a38812af1f1ae25f815c04494fcf459","modified":1555402577496},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1555309775462},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1555309775490},{"_id":"source/img/header_img/computer.jpg","hash":"fe89881953575ebf108822875424395bb5ed10d2","modified":1555412207703},{"_id":"source/img/header_img/xirikui.jpg","hash":"0df1f82b24e2015fd4611cfc24a10647b1db164c","modified":1555416108617},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1555309775907},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1555309776018},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1555309776051},{"_id":"source/img/article/github-pages.png","hash":"6d640742e3d0377bda56c1920b36f120e137362a","modified":1555385533833},{"_id":"source/img/pay/wechat_pay.png","hash":"1503eb2c9206aac256787b1bed84f9c3452e0a4d","modified":1555309775687},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1555309775716},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1555309775370},{"_id":"source/img/header_img/moutain.jpg","hash":"2233c072ae023771f84b46346b0bb0104693963f","modified":1555416176710},{"_id":"source/img/header_img/pencil.jpg","hash":"5f8f4b11e0dbe4e685fbca95391005ab4b8ca423","modified":1555416151967},{"_id":"source/img/header_img/road2.jpg","hash":"c9ff82ce7b69c2e410684bd2ba0f51d8a5c5790c","modified":1555416031951},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1555309776291},{"_id":"source/img/pay/ali_pay.png","hash":"15b04dda349b629e4c996a3390a2e620c4d5b269","modified":1555309775658},{"_id":"source/img/article/test-data-platform.png","hash":"5655aec4463fecfd38c3f97bf027d4a17959f00d","modified":1555400517411},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1555309775331},{"_id":"source/img/header_img/road.jpg","hash":"941e6bcf770827b5bd392ce9bfabe77c93a5259c","modified":1555415993861},{"_id":"source/img/article/domain.jpeg","hash":"07cdfcd896dfad648b5526af5f5b3b9eb3150665","modified":1555385533742},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1555309775280},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1555309775558},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1555309775628},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555309775361},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1555309775526},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1555309775595},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1555309775407}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-04-15T06:29:35.200Z","updated":"2019-04-15T06:29:35.200Z","path":"404.html","title":"","comments":1,"_id":"cjumd63dy0000xh9vixmgrpbe","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2019-04-15T02:48:33.000Z","description":"不断改进软件测试方法","header-img":"/img/header_img/about.jpg","aplayer":false,"fixed":false,"_content":"\n### 一句话\n\n> 在实践中提高，在交流中进步。\n\n### 关于我\n\n>喜欢研究技术，也喜欢分享。\n>\n>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。\n>\n>希望写一些对大家有用的文字。\n\n### 兴趣方向\n\n> 引进新的技术，不断改进软件测试方法\n\n### 参与社区\n\n > CSDN博客：httsp://blog.csdn.et/liuchunming033\n >\n > Github：https://github.com/liuchunming033\n > \n > 2018全球架构师峰会：https://bj2018.archsummit.com/presentation/1330\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2019-04-15 10:48:33\ndescription: \"不断改进软件测试方法\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false \nfixed: false\n---\n\n### 一句话\n\n> 在实践中提高，在交流中进步。\n\n### 关于我\n\n>喜欢研究技术，也喜欢分享。\n>\n>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。\n>\n>希望写一些对大家有用的文字。\n\n### 兴趣方向\n\n> 引进新的技术，不断改进软件测试方法\n\n### 参与社区\n\n > CSDN博客：httsp://blog.csdn.et/liuchunming033\n >\n > Github：https://github.com/liuchunming033\n > \n > 2018全球架构师峰会：https://bj2018.archsummit.com/presentation/1330\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n\n","updated":"2019-04-18T07:03:58.200Z","path":"about/index.html","comments":1,"_id":"cjumd63eu0002xh9v66c7j5gn","content":"<h3 id=\"一句话\">一句话</h3>\n<blockquote>\n<p>在实践中提高，在交流中进步。</p>\n</blockquote>\n<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>喜欢研究技术，也喜欢分享。</p>\n<p>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。</p>\n<p>希望写一些对大家有用的文字。</p>\n</blockquote>\n<h3 id=\"兴趣方向\">兴趣方向</h3>\n<blockquote>\n<p>引进新的技术，不断改进软件测试方法</p>\n</blockquote>\n<h3 id=\"参与社区\">参与社区</h3>\n<blockquote>\n<p>CSDN博客：httsp://blog.csdn.et/liuchunming033</p>\n<p>Github：<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n<p>2018全球架构师峰会：<a href=\"https://bj2018.archsummit.com/presentation/1330\" target=\"_blank\" rel=\"noopener\">https://bj2018.archsummit.com/presentation/1330</a></p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>在实践中提高，在交流中进步。</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>喜欢研究技术，也喜欢分享。</p>\n<p>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。</p>\n<p>希望写一些对大家有用的文字。</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>引进新的技术，不断改进软件测试方法</p>\n</blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>CSDN博客：httsp://blog.csdn.et/liuchunming033</p>\n<p>Github：<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n<p>2018全球架构师峰会：<a href=\"https://bj2018.archsummit.com/presentation/1330\" target=\"_blank\" rel=\"noopener\">https://bj2018.archsummit.com/presentation/1330</a></p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-04-15T06:29:35.272Z","path":"archive/index.html","_id":"cjumd63ew0004xh9vd9pji7nh","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-04-15T06:29:35.769Z","updated":"2019-04-15T06:29:35.769Z","path":"tags/index.html","comments":1,"_id":"cjumd63gv000dxh9vbuzahham","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"自动化软件测试中测试环境的演进","catalog":true,"toc_nav_num":true,"date":"2019-04-16T11:51:24.000Z","subtitle":"从单机单环境到基于Kubernetes的测试集群","header-img":"/img/article_header/bullon.jpg","catagories":["软件测试"],"_content":"","source":"_posts/软件自动化测试中的测试环境演进之路.md","raw":"---\ntitle: \"自动化软件测试中测试环境的演进\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-16 19:51:24\nsubtitle: \"从单机单环境到基于Kubernetes的测试集群\"\nheader-img: \"/img/article_header/bullon.jpg\"\ntags:\n- 软件测试\n- Kubernates\n- Docker\ncatagories:\n- 软件测试\n---","slug":"软件自动化测试中的测试环境演进之路","published":1,"updated":"2019-04-18T08:42:16.697Z","_id":"cjumd63eq0001xh9vybo0en8i","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hexo博客入门","catalog":true,"toc_nav_num":true,"date":"2019-04-15T02:51:24.000Z","subtitle":"从0开始搭建Hexo博客","header-img":"/img/article_header/article_header.png","top":9,"catagories":["Hexo"],"_content":"\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","source":"_posts/Hexo博客入门.md","raw":"---\ntitle: \"Hexo博客入门\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-15 10:51:24\nsubtitle: \"从0开始搭建Hexo博客\"\nheader-img: \"/img/article_header/article_header.png\"\ntop: 9\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","slug":"Hexo博客入门","published":1,"updated":"2019-04-16T03:32:13.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumd63ev0003xh9vj4hrvckm","content":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2 id=\"安装hexo\">安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速启动一个博客\">快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2 id=\"创建一篇自己的博文\">创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2 id=\"让更多人看到你的博客\">让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3 id=\"新建github仓库\">新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3 id=\"设置部署选项\">设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3 id=\"部署博客站点到github\">部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3 id=\"配置https和自定义域名\">配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2 id=\"个性化主题\">个性化主题</h2>\n<h3 id=\"更换主题模板\">更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3 id=\"边栏设置\">边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3 id=\"评论区设置\">评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3 id=\"相关文章设置\">相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2>安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2>快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2>创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2>让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3>新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3>设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3>部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3>配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2>个性化主题</h2>\n<h3>更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3>边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3>评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3>相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n"},{"title":"如何定制和管理自动化测试报告","catalog":true,"toc_nav_num":true,"date":"2019-04-16T11:51:24.000Z","subtitle":"基于Pytest+Allure+Django Rest framework+Vue定制和管理自动化测试报告","header-img":"/img/article_header/computer.jpg","catagories":["软件测试"],"_content":"\n>对于软件测试来说，测试报告是非常重要的工作产出。一个漂亮、清晰、格式规范的测试报告，不仅能够方便定位缺陷的位置，也方便开发人员和测试人员进行沟通。\n\n## 自动化测试报告应该包含哪些内容\n自动化测试报告应该自动化测试用例执行完成后自动生成的。我认为，一份完整的自动化测试报告应该包含以下几个方面：\n - *测试总体结论。* 用来标识本次测试是通过还是失败。\n - *测试概要信息。* 用来统计本次测试通过的用例的数量、失败的用例数量、Skipped的用例数量等。\n - *测试用例的执行结果。* 用来表示每条自动化测试用例是通过还是失败，如果失败，测试用例具体失败在哪一行。\n - *测试执行时长。* 表示本次测试花了多长时间。\n - *测试环境信息。* 表示本次测试相关的测试配置和测试环境。\n \n本篇文章将介绍如何使用开源的测试报告生成框架Allure生成规范、格式统一、美观的测试报告。\n通过这篇文章的介绍，你将能够：\n - 将Allure与Pytest测试框架相结合；\n - 定制美观的测试报告；\n - 生成和查看Allure格式的测试报告；\n - 对所有的自动化测试报告进行统一管理。\n\n## 安装Allure及Pytest插件\n [Allure](http://allure.qatools.ru/)是一款非常轻量级并且非常灵活的开源测试报告生成框架。 它支持绝大多数测试框架， 例如TestNG、Pytest、JUint等。它简单易用，易于集成。下面就Pytest如何与Allure集成做详细介绍。\n安装Allure\n```\nbrew install allure\n```\nPytest是Python的单元测试框架，非常方便和易用。强烈推荐对于用Python进行测试工作的小伙伴使用这个测试框架，相比与Python自带的UnitTest好用太多太多。后面我将用一整篇文章介绍Pytest测试框架。今天我们主要是介绍如何将测试报告生成工具Allure集成到Pytest中。\n\n[allure-pytest](https://pypi.org/project/allure-pytest/)是Pytest的Allure插件，通过它可以生成Allure所需要的用于生成测试报告的数据。安装方法：\n```\n$ pip install allure-pytest\n```\n这样有关测试报告用到的库都已经安装好了。接下来我们来定制我们的测试报告吧。\n## 定制测试报告内容\npytest-allure-adaptor官网中详细介绍了pytest-allure-adaptor所具有的功能。本篇文章不会再翻译一遍，而是从实际入手，给大家介绍如何将其应用到自己的框架中。\n为了使用Allure生成报告，需要在conftest.py和测试脚本中加入Allure特性。\n\n首先，conftest.py中可以通过allure.environment方法将测试环境的信息输出到报告中，比如将测试时用的host和测试用的browser添加到测试报告中：\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nimport pytest\nimport allure\nimport yaml\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef env(request):\n    \"\"\"\n    Parse env config info\n    \"\"\"\n    root_dir = request.config.rootdir\n    config_path = '{0}/config/env_config.yml'.format(root_dir)\n    with open(config_path) as f:\n        env_config = yaml.load(f) # 读取配置文件\n\n    allure.environment(host=env_config['host']['domain']) # 测试报告中展示host\n    allure.environment(browser=env_config['host']['browser']) # 测试报告中展示browser\n\n    return env_config\n\n```\n接着，在测试脚本中，添加allure特性，直接看下面的脚本，我通过在脚本中添加注释的方式给大家解释allure特性的用途。比如测试脚本是test_shopping_trolley.py：\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nimport pytest\nimport allure\n\n\n@allure.feature('购物车功能')  # feature定义功能\nclass TestShoppingTrolley(object):\n    @allure.story('加入购物车')  # story定义用户场景\n    def test_add_shopping_trolley(self):\n        login('刘春明', '密码')  # 调用“步骤函数”\n        with allure.step(\"浏览商品\"):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤2\n            allure.attach('商品1', '刘春明')  # attach可以打印一些附加信息\n            allure.attach('商品2', 'liuchunming')\n        with allure.step(\"点击商品\"):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤3\n            pass\n        with allure.step(\"校验结果\"):\n            allure.attach('期望结果', '添加购物车成功')\n            allure.attach('实际结果', '添加购物车失败')\n            assert 'success' == 'failed'\n\n    @allure.story('修改购物车')\n    def test_edit_shopping_trolley(self):\n        pass\n\n    @pytest.mark.skipif(reason='本次不执行')\n    @allure.story('删除购物车')\n    def test_delete_shopping_trolley(self):\n        pass\n\n\n@allure.step('用户登录')  # 还可以将一个函数作为一个步骤，调用此函数时，报告中输出一个步骤，步骤名字通常是函数名，我把这样的函数叫“步骤函数”\ndef login(user, pwd):\n    print(user, pwd)\n\n```\n上面使用了Allure的几个特性：\n\n - @allure.feature # 用于定义被测试的功能，被测产品的需求点\n - @allure.story # 用于定义被测功能的用户场景，即子功能点\n - with allure.step # 用于将一个测试用例，分成几个步骤在报告中输出\n - allure.attach # 用于向测试报告中输入一些附加的信息，通常是一些测试数据信息\n - @allure.step # 用于将一些通用的函数作为测试步骤输出到报告，调用此函数的地方会向报告中输出步骤\n - allure.environment # pytest暂不支持\n\n## 生成Allure测试报告\n### 生成报告原始数据\n测试用例中添加了Allure特性之后，在执行测试的时候需要先生成Allure报告所需要的测试结果数据。在py.test执行测试的时候，指定--alluredir选项及测试数据保存的目录即可：\n```\n$ py.test test/ --alluredir ./result/\n```\n另外，还可以执行指定features或者stories执行一部分测试用例，比如执行‘购物车功能’下的‘加入购物车’子功能的测试用例：\n```\n$ py.test test/ --allure_features='购物车功能' --allure_stories='加入购物车' --alluredir ./result/\n```\n### 生成allure格式测试报告\n./result/中保存了测试结果数据。接着，执行利用上面命令产生的测试结果数据./result/生成Allure测试报告：\n```shell\n$ allure generate ./result/ -o ./report/ --clean\n```\n可以通过下面的命令打开测试报告：\n```\n$ allure open -h 127.0.0.1 -p 8083 ./report/\n```\n在浏览器打开http://127.0.0.1:8083网页，展示测试报告。\n\n## 测试报告解读\n打开生成的测试报告后，浏览器被自动调起，展示测试报告。下面我们分别看看测试报告的几个页面。\n\n 1. 首页\n![这里写图片描述](http://img.blog.csdn.net/20180320200100881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n首页中展示了本次测试的测试用例数量，成功用例、失败用例、跳过用例的比例，测试环境信息，SUITES，FEATURES BY STORIES等基本信息，当与Jenkins做了持续置成后，TREND区域还将显示，历次测试的通过情况。\n首页的左边栏，还从不同的维度展示测试报告的其他信息，大家可以自己点进去看看。\n 2. Behaviors\n接下来，我们点击一下FEATURES BY STORIES，将进入Behaviors页面，这个页面按照FEATURES和 STORIES展示测试用例的执行结果：\n![这里写图片描述](http://img.blog.csdn.net/20180320200600472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n从这个页面可以看到“购物车功能”这个FEATURES包含的三个STORIES的测试用例执行情况。\n 3. Suites\nAllure测试报告将每一个测试脚本，作为一个Suite。在首页点击Suites区域下面的任何一条Suite，都将进入Suites页面。\n![这里写图片描述](http://img.blog.csdn.net/20180320201059219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这个页面，将脚本的目录结果展示本次所有的测试用例执行情况。\n 4. 测试用例页面\n 在Suites页面上点击任何一条测试用例，Suites页面的右侧将展示这条用例的详细执行情况。\n![这里写图片描述](http://img.blog.csdn.net/20180320201409629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n从这个页面可以看到测试用例执行的每一个步骤，以及每个步骤的执行结果。测试用例为什么失败，这里一目了然。\n\n### 利用Jenkins生成测试报告\n前面我们通过命令行方法生成测试报告，通常是在本地调试时候使用。而真正的自动化测试一定是与持续集成相结合的，比如利用Jenkins进行测试的自动执行。\n要想在持续集成中自动生成测试报告，首先需要给Jenkins安装Allure Plugin。在Jenkins的插件管理页面，搜索“allure”，在搜索结果页，选择“Allure Jenkins Plugin”进行安装。\n安装完成之后重启一下Jenkins。\n在Jenkins的“全局工具管理”页面，找到Allure Commandline模块进行安装：\n![这里写图片描述](http://img.blog.csdn.net/20180320175830037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n点击后，弹出下面的页面，输入Allure的命令别名和版本后，点击Apply 和Save。\n![这里写图片描述](http://img.blog.csdn.net/20180320180250524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n按照下面的图示，在Excute Shell和构建后操作部分写上对应的配置信息，即可。\n![这里写图片描述](http://img.blog.csdn.net/20180320182135772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这样，我们的Jenkins Job执行完测试用例时候，将在Job的主页面上看到Allure Report图标，点击进去就看到了Allure Report报告。\n![这里写图片描述](http://img.blog.csdn.net/20180320182403557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n团队内部可能不同项目使用的测试框架不一样，每个测试框架生成的测试报告也不一样。但由于Allure报告支持很多测试框架，通过Allure可以生成格式一致的测试报告，这就对外提供格式一致的测试报告提供了方便。\n建议：团队内部都采用Allure生成测试报告。\n由于团队内部有的项目采用的Java+TestNG的测试架构，后面有时间，我将会介绍一下如何在TestNG框架如何集成Allure。\n\n## 测试报告管理平台\n我们希望能够把历次的测试报告进行存档和保留，方便以后查看或者对软件的质量进行度量。\n下面我们就来基于Django REST framework和Vue来实现测试报告的展示和管理平台\n### 测试报告元数据\n用pytest-json-report可以获得测试报告的生成时间、测试的结果、测试执行时间、每条测试用例的结果以及测试用例失败的原因。\n### 测试报告静态网页\n通过接口上传到文件服务器\n### 编写前端页面\nVue\n### 用Nginx做反向代理\n根据location代理到文件服务器\n### 部署\n\n## 总结\n总结前面的实践，展望：自动生成BUG候选列表，与JIRA对接。","source":"_posts/如何定制和管理自动化测试中的测试报告.md","raw":"---\ntitle: \"如何定制和管理自动化测试报告\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-16 19:51:24\nsubtitle: \"基于Pytest+Allure+Django Rest framework+Vue定制和管理自动化测试报告\"\nheader-img: \"/img/article_header/computer.jpg\"\ntags:\n- 软件测试\n- Allure\ncatagories:\n- 软件测试\n---\n\n>对于软件测试来说，测试报告是非常重要的工作产出。一个漂亮、清晰、格式规范的测试报告，不仅能够方便定位缺陷的位置，也方便开发人员和测试人员进行沟通。\n\n## 自动化测试报告应该包含哪些内容\n自动化测试报告应该自动化测试用例执行完成后自动生成的。我认为，一份完整的自动化测试报告应该包含以下几个方面：\n - *测试总体结论。* 用来标识本次测试是通过还是失败。\n - *测试概要信息。* 用来统计本次测试通过的用例的数量、失败的用例数量、Skipped的用例数量等。\n - *测试用例的执行结果。* 用来表示每条自动化测试用例是通过还是失败，如果失败，测试用例具体失败在哪一行。\n - *测试执行时长。* 表示本次测试花了多长时间。\n - *测试环境信息。* 表示本次测试相关的测试配置和测试环境。\n \n本篇文章将介绍如何使用开源的测试报告生成框架Allure生成规范、格式统一、美观的测试报告。\n通过这篇文章的介绍，你将能够：\n - 将Allure与Pytest测试框架相结合；\n - 定制美观的测试报告；\n - 生成和查看Allure格式的测试报告；\n - 对所有的自动化测试报告进行统一管理。\n\n## 安装Allure及Pytest插件\n [Allure](http://allure.qatools.ru/)是一款非常轻量级并且非常灵活的开源测试报告生成框架。 它支持绝大多数测试框架， 例如TestNG、Pytest、JUint等。它简单易用，易于集成。下面就Pytest如何与Allure集成做详细介绍。\n安装Allure\n```\nbrew install allure\n```\nPytest是Python的单元测试框架，非常方便和易用。强烈推荐对于用Python进行测试工作的小伙伴使用这个测试框架，相比与Python自带的UnitTest好用太多太多。后面我将用一整篇文章介绍Pytest测试框架。今天我们主要是介绍如何将测试报告生成工具Allure集成到Pytest中。\n\n[allure-pytest](https://pypi.org/project/allure-pytest/)是Pytest的Allure插件，通过它可以生成Allure所需要的用于生成测试报告的数据。安装方法：\n```\n$ pip install allure-pytest\n```\n这样有关测试报告用到的库都已经安装好了。接下来我们来定制我们的测试报告吧。\n## 定制测试报告内容\npytest-allure-adaptor官网中详细介绍了pytest-allure-adaptor所具有的功能。本篇文章不会再翻译一遍，而是从实际入手，给大家介绍如何将其应用到自己的框架中。\n为了使用Allure生成报告，需要在conftest.py和测试脚本中加入Allure特性。\n\n首先，conftest.py中可以通过allure.environment方法将测试环境的信息输出到报告中，比如将测试时用的host和测试用的browser添加到测试报告中：\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nimport pytest\nimport allure\nimport yaml\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef env(request):\n    \"\"\"\n    Parse env config info\n    \"\"\"\n    root_dir = request.config.rootdir\n    config_path = '{0}/config/env_config.yml'.format(root_dir)\n    with open(config_path) as f:\n        env_config = yaml.load(f) # 读取配置文件\n\n    allure.environment(host=env_config['host']['domain']) # 测试报告中展示host\n    allure.environment(browser=env_config['host']['browser']) # 测试报告中展示browser\n\n    return env_config\n\n```\n接着，在测试脚本中，添加allure特性，直接看下面的脚本，我通过在脚本中添加注释的方式给大家解释allure特性的用途。比如测试脚本是test_shopping_trolley.py：\n```\n#!/usr/bin/env python\n# coding=utf-8\n\nimport pytest\nimport allure\n\n\n@allure.feature('购物车功能')  # feature定义功能\nclass TestShoppingTrolley(object):\n    @allure.story('加入购物车')  # story定义用户场景\n    def test_add_shopping_trolley(self):\n        login('刘春明', '密码')  # 调用“步骤函数”\n        with allure.step(\"浏览商品\"):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤2\n            allure.attach('商品1', '刘春明')  # attach可以打印一些附加信息\n            allure.attach('商品2', 'liuchunming')\n        with allure.step(\"点击商品\"):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤3\n            pass\n        with allure.step(\"校验结果\"):\n            allure.attach('期望结果', '添加购物车成功')\n            allure.attach('实际结果', '添加购物车失败')\n            assert 'success' == 'failed'\n\n    @allure.story('修改购物车')\n    def test_edit_shopping_trolley(self):\n        pass\n\n    @pytest.mark.skipif(reason='本次不执行')\n    @allure.story('删除购物车')\n    def test_delete_shopping_trolley(self):\n        pass\n\n\n@allure.step('用户登录')  # 还可以将一个函数作为一个步骤，调用此函数时，报告中输出一个步骤，步骤名字通常是函数名，我把这样的函数叫“步骤函数”\ndef login(user, pwd):\n    print(user, pwd)\n\n```\n上面使用了Allure的几个特性：\n\n - @allure.feature # 用于定义被测试的功能，被测产品的需求点\n - @allure.story # 用于定义被测功能的用户场景，即子功能点\n - with allure.step # 用于将一个测试用例，分成几个步骤在报告中输出\n - allure.attach # 用于向测试报告中输入一些附加的信息，通常是一些测试数据信息\n - @allure.step # 用于将一些通用的函数作为测试步骤输出到报告，调用此函数的地方会向报告中输出步骤\n - allure.environment # pytest暂不支持\n\n## 生成Allure测试报告\n### 生成报告原始数据\n测试用例中添加了Allure特性之后，在执行测试的时候需要先生成Allure报告所需要的测试结果数据。在py.test执行测试的时候，指定--alluredir选项及测试数据保存的目录即可：\n```\n$ py.test test/ --alluredir ./result/\n```\n另外，还可以执行指定features或者stories执行一部分测试用例，比如执行‘购物车功能’下的‘加入购物车’子功能的测试用例：\n```\n$ py.test test/ --allure_features='购物车功能' --allure_stories='加入购物车' --alluredir ./result/\n```\n### 生成allure格式测试报告\n./result/中保存了测试结果数据。接着，执行利用上面命令产生的测试结果数据./result/生成Allure测试报告：\n```shell\n$ allure generate ./result/ -o ./report/ --clean\n```\n可以通过下面的命令打开测试报告：\n```\n$ allure open -h 127.0.0.1 -p 8083 ./report/\n```\n在浏览器打开http://127.0.0.1:8083网页，展示测试报告。\n\n## 测试报告解读\n打开生成的测试报告后，浏览器被自动调起，展示测试报告。下面我们分别看看测试报告的几个页面。\n\n 1. 首页\n![这里写图片描述](http://img.blog.csdn.net/20180320200100881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n首页中展示了本次测试的测试用例数量，成功用例、失败用例、跳过用例的比例，测试环境信息，SUITES，FEATURES BY STORIES等基本信息，当与Jenkins做了持续置成后，TREND区域还将显示，历次测试的通过情况。\n首页的左边栏，还从不同的维度展示测试报告的其他信息，大家可以自己点进去看看。\n 2. Behaviors\n接下来，我们点击一下FEATURES BY STORIES，将进入Behaviors页面，这个页面按照FEATURES和 STORIES展示测试用例的执行结果：\n![这里写图片描述](http://img.blog.csdn.net/20180320200600472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n从这个页面可以看到“购物车功能”这个FEATURES包含的三个STORIES的测试用例执行情况。\n 3. Suites\nAllure测试报告将每一个测试脚本，作为一个Suite。在首页点击Suites区域下面的任何一条Suite，都将进入Suites页面。\n![这里写图片描述](http://img.blog.csdn.net/20180320201059219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这个页面，将脚本的目录结果展示本次所有的测试用例执行情况。\n 4. 测试用例页面\n 在Suites页面上点击任何一条测试用例，Suites页面的右侧将展示这条用例的详细执行情况。\n![这里写图片描述](http://img.blog.csdn.net/20180320201409629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n从这个页面可以看到测试用例执行的每一个步骤，以及每个步骤的执行结果。测试用例为什么失败，这里一目了然。\n\n### 利用Jenkins生成测试报告\n前面我们通过命令行方法生成测试报告，通常是在本地调试时候使用。而真正的自动化测试一定是与持续集成相结合的，比如利用Jenkins进行测试的自动执行。\n要想在持续集成中自动生成测试报告，首先需要给Jenkins安装Allure Plugin。在Jenkins的插件管理页面，搜索“allure”，在搜索结果页，选择“Allure Jenkins Plugin”进行安装。\n安装完成之后重启一下Jenkins。\n在Jenkins的“全局工具管理”页面，找到Allure Commandline模块进行安装：\n![这里写图片描述](http://img.blog.csdn.net/20180320175830037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n点击后，弹出下面的页面，输入Allure的命令别名和版本后，点击Apply 和Save。\n![这里写图片描述](http://img.blog.csdn.net/20180320180250524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n按照下面的图示，在Excute Shell和构建后操作部分写上对应的配置信息，即可。\n![这里写图片描述](http://img.blog.csdn.net/20180320182135772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这样，我们的Jenkins Job执行完测试用例时候，将在Job的主页面上看到Allure Report图标，点击进去就看到了Allure Report报告。\n![这里写图片描述](http://img.blog.csdn.net/20180320182403557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n团队内部可能不同项目使用的测试框架不一样，每个测试框架生成的测试报告也不一样。但由于Allure报告支持很多测试框架，通过Allure可以生成格式一致的测试报告，这就对外提供格式一致的测试报告提供了方便。\n建议：团队内部都采用Allure生成测试报告。\n由于团队内部有的项目采用的Java+TestNG的测试架构，后面有时间，我将会介绍一下如何在TestNG框架如何集成Allure。\n\n## 测试报告管理平台\n我们希望能够把历次的测试报告进行存档和保留，方便以后查看或者对软件的质量进行度量。\n下面我们就来基于Django REST framework和Vue来实现测试报告的展示和管理平台\n### 测试报告元数据\n用pytest-json-report可以获得测试报告的生成时间、测试的结果、测试执行时间、每条测试用例的结果以及测试用例失败的原因。\n### 测试报告静态网页\n通过接口上传到文件服务器\n### 编写前端页面\nVue\n### 用Nginx做反向代理\n根据location代理到文件服务器\n### 部署\n\n## 总结\n总结前面的实践，展望：自动生成BUG候选列表，与JIRA对接。","slug":"如何定制和管理自动化测试中的测试报告","published":1,"updated":"2019-04-18T10:50:18.238Z","_id":"cjumd63ey0005xh9vxjyach16","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>对于软件测试来说，测试报告是非常重要的工作产出。一个漂亮、清晰、格式规范的测试报告，不仅能够方便定位缺陷的位置，也方便开发人员和测试人员进行沟通。</p>\n</blockquote>\n<h2 id=\"自动化测试报告应该包含哪些内容\">自动化测试报告应该包含哪些内容</h2>\n<p>自动化测试报告应该自动化测试用例执行完成后自动生成的。我认为，一份完整的自动化测试报告应该包含以下几个方面：</p>\n<ul>\n<li><em>测试总体结论。</em> 用来标识本次测试是通过还是失败。</li>\n<li><em>测试概要信息。</em> 用来统计本次测试通过的用例的数量、失败的用例数量、Skipped的用例数量等。</li>\n<li><em>测试用例的执行结果。</em> 用来表示每条自动化测试用例是通过还是失败，如果失败，测试用例具体失败在哪一行。</li>\n<li><em>测试执行时长。</em> 表示本次测试花了多长时间。</li>\n<li><em>测试环境信息。</em> 表示本次测试相关的测试配置和测试环境。</li>\n</ul>\n<p>本篇文章将介绍如何使用开源的测试报告生成框架Allure生成规范、格式统一、美观的测试报告。<br>\n通过这篇文章的介绍，你将能够：</p>\n<ul>\n<li>将Allure与Pytest测试框架相结合；</li>\n<li>定制美观的测试报告；</li>\n<li>生成和查看Allure格式的测试报告；</li>\n<li>对所有的自动化测试报告进行统一管理。</li>\n</ul>\n<h2 id=\"安装allure及pytest插件\">安装Allure及Pytest插件</h2>\n<p><a href=\"http://allure.qatools.ru/\" target=\"_blank\" rel=\"noopener\">Allure</a>是一款非常轻量级并且非常灵活的开源测试报告生成框架。 它支持绝大多数测试框架， 例如TestNG、Pytest、JUint等。它简单易用，易于集成。下面就Pytest如何与Allure集成做详细介绍。<br>\n安装Allure</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install allure</span><br></pre></td></tr></table></figure>\n<p>Pytest是Python的单元测试框架，非常方便和易用。强烈推荐对于用Python进行测试工作的小伙伴使用这个测试框架，相比与Python自带的UnitTest好用太多太多。后面我将用一整篇文章介绍Pytest测试框架。今天我们主要是介绍如何将测试报告生成工具Allure集成到Pytest中。</p>\n<p><a href=\"https://pypi.org/project/allure-pytest/\" target=\"_blank\" rel=\"noopener\">allure-pytest</a>是Pytest的Allure插件，通过它可以生成Allure所需要的用于生成测试报告的数据。安装方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install allure-pytest</span><br></pre></td></tr></table></figure>\n<p>这样有关测试报告用到的库都已经安装好了。接下来我们来定制我们的测试报告吧。</p>\n<h2 id=\"定制测试报告内容\">定制测试报告内容</h2>\n<p>pytest-allure-adaptor官网中详细介绍了pytest-allure-adaptor所具有的功能。本篇文章不会再翻译一遍，而是从实际入手，给大家介绍如何将其应用到自己的框架中。<br>\n为了使用Allure生成报告，需要在conftest.py和测试脚本中加入Allure特性。</p>\n<p>首先，conftest.py中可以通过allure.environment方法将测试环境的信息输出到报告中，比如将测试时用的host和测试用的browser添加到测试报告中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># coding=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">import pytest</span><br><span class=\"line\">import allure</span><br><span class=\"line\">import yaml</span><br><span class=\"line\"></span><br><span class=\"line\">@pytest.fixture(scope=&quot;session&quot;, autouse=True)</span><br><span class=\"line\">def env(request):</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    Parse env config info</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    root_dir = request.config.rootdir</span><br><span class=\"line\">    config_path = &apos;&#123;0&#125;/config/env_config.yml&apos;.format(root_dir)</span><br><span class=\"line\">    with open(config_path) as f:</span><br><span class=\"line\">        env_config = yaml.load(f) # 读取配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">    allure.environment(host=env_config[&apos;host&apos;][&apos;domain&apos;]) # 测试报告中展示host</span><br><span class=\"line\">    allure.environment(browser=env_config[&apos;host&apos;][&apos;browser&apos;]) # 测试报告中展示browser</span><br><span class=\"line\"></span><br><span class=\"line\">    return env_config</span><br></pre></td></tr></table></figure>\n<p>接着，在测试脚本中，添加allure特性，直接看下面的脚本，我通过在脚本中添加注释的方式给大家解释allure特性的用途。比如测试脚本是test_shopping_trolley.py：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># coding=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">import pytest</span><br><span class=\"line\">import allure</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@allure.feature(&apos;购物车功能&apos;)  # feature定义功能</span><br><span class=\"line\">class TestShoppingTrolley(object):</span><br><span class=\"line\">    @allure.story(&apos;加入购物车&apos;)  # story定义用户场景</span><br><span class=\"line\">    def test_add_shopping_trolley(self):</span><br><span class=\"line\">        login(&apos;刘春明&apos;, &apos;密码&apos;)  # 调用“步骤函数”</span><br><span class=\"line\">        with allure.step(&quot;浏览商品&quot;):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤2</span><br><span class=\"line\">            allure.attach(&apos;商品1&apos;, &apos;刘春明&apos;)  # attach可以打印一些附加信息</span><br><span class=\"line\">            allure.attach(&apos;商品2&apos;, &apos;liuchunming&apos;)</span><br><span class=\"line\">        with allure.step(&quot;点击商品&quot;):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤3</span><br><span class=\"line\">            pass</span><br><span class=\"line\">        with allure.step(&quot;校验结果&quot;):</span><br><span class=\"line\">            allure.attach(&apos;期望结果&apos;, &apos;添加购物车成功&apos;)</span><br><span class=\"line\">            allure.attach(&apos;实际结果&apos;, &apos;添加购物车失败&apos;)</span><br><span class=\"line\">            assert &apos;success&apos; == &apos;failed&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    @allure.story(&apos;修改购物车&apos;)</span><br><span class=\"line\">    def test_edit_shopping_trolley(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">    @pytest.mark.skipif(reason=&apos;本次不执行&apos;)</span><br><span class=\"line\">    @allure.story(&apos;删除购物车&apos;)</span><br><span class=\"line\">    def test_delete_shopping_trolley(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@allure.step(&apos;用户登录&apos;)  # 还可以将一个函数作为一个步骤，调用此函数时，报告中输出一个步骤，步骤名字通常是函数名，我把这样的函数叫“步骤函数”</span><br><span class=\"line\">def login(user, pwd):</span><br><span class=\"line\">    print(user, pwd)</span><br></pre></td></tr></table></figure>\n<p>上面使用了Allure的几个特性：</p>\n<ul>\n<li>@allure.feature # 用于定义被测试的功能，被测产品的需求点</li>\n<li>@allure.story # 用于定义被测功能的用户场景，即子功能点</li>\n<li>with allure.step # 用于将一个测试用例，分成几个步骤在报告中输出</li>\n<li>allure.attach # 用于向测试报告中输入一些附加的信息，通常是一些测试数据信息</li>\n<li>@allure.step # 用于将一些通用的函数作为测试步骤输出到报告，调用此函数的地方会向报告中输出步骤</li>\n<li>allure.environment # pytest暂不支持</li>\n</ul>\n<h2 id=\"生成allure测试报告\">生成Allure测试报告</h2>\n<h3 id=\"生成报告原始数据\">生成报告原始数据</h3>\n<p>测试用例中添加了Allure特性之后，在执行测试的时候需要先生成Allure报告所需要的测试结果数据。在py.test执行测试的时候，指定–alluredir选项及测试数据保存的目录即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ py.test test/ --alluredir ./result/</span><br></pre></td></tr></table></figure>\n<p>另外，还可以执行指定features或者stories执行一部分测试用例，比如执行‘购物车功能’下的‘加入购物车’子功能的测试用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ py.test test/ --allure_features=&apos;购物车功能&apos; --allure_stories=&apos;加入购物车&apos; --alluredir ./result/</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成allure格式测试报告\">生成allure格式测试报告</h3>\n<p>./result/中保存了测试结果数据。接着，执行利用上面命令产生的测试结果数据./result/生成Allure测试报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> allure generate ./result/ -o ./report/ --clean</span><br></pre></td></tr></table></figure>\n<p>可以通过下面的命令打开测试报告：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ allure open -h 127.0.0.1 -p 8083 ./report/</span><br></pre></td></tr></table></figure>\n<p>在浏览器打开http://127.0.0.1:8083网页，展示测试报告。</p>\n<h2 id=\"测试报告解读\">测试报告解读</h2>\n<p>打开生成的测试报告后，浏览器被自动调起，展示测试报告。下面我们分别看看测试报告的几个页面。</p>\n<ol>\n<li>首页<br>\n<img src=\"http://img.blog.csdn.net/20180320200100881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n首页中展示了本次测试的测试用例数量，成功用例、失败用例、跳过用例的比例，测试环境信息，SUITES，FEATURES BY STORIES等基本信息，当与Jenkins做了持续置成后，TREND区域还将显示，历次测试的通过情况。<br>\n首页的左边栏，还从不同的维度展示测试报告的其他信息，大家可以自己点进去看看。</li>\n<li>Behaviors<br>\n接下来，我们点击一下FEATURES BY STORIES，将进入Behaviors页面，这个页面按照FEATURES和 STORIES展示测试用例的执行结果：<br>\n<img src=\"http://img.blog.csdn.net/20180320200600472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n从这个页面可以看到“购物车功能”这个FEATURES包含的三个STORIES的测试用例执行情况。</li>\n<li>Suites<br>\nAllure测试报告将每一个测试脚本，作为一个Suite。在首页点击Suites区域下面的任何一条Suite，都将进入Suites页面。<br>\n<img src=\"http://img.blog.csdn.net/20180320201059219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n这个页面，将脚本的目录结果展示本次所有的测试用例执行情况。</li>\n<li>测试用例页面<br>\n在Suites页面上点击任何一条测试用例，Suites页面的右侧将展示这条用例的详细执行情况。<br>\n<img src=\"http://img.blog.csdn.net/20180320201409629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n从这个页面可以看到测试用例执行的每一个步骤，以及每个步骤的执行结果。测试用例为什么失败，这里一目了然。</li>\n</ol>\n<h3 id=\"利用jenkins生成测试报告\">利用Jenkins生成测试报告</h3>\n<p>前面我们通过命令行方法生成测试报告，通常是在本地调试时候使用。而真正的自动化测试一定是与持续集成相结合的，比如利用Jenkins进行测试的自动执行。<br>\n要想在持续集成中自动生成测试报告，首先需要给Jenkins安装Allure Plugin。在Jenkins的插件管理页面，搜索“allure”，在搜索结果页，选择“Allure Jenkins Plugin”进行安装。<br>\n安装完成之后重启一下Jenkins。<br>\n在Jenkins的“全局工具管理”页面，找到Allure Commandline模块进行安装：<br>\n<img src=\"http://img.blog.csdn.net/20180320175830037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n点击后，弹出下面的页面，输入Allure的命令别名和版本后，点击Apply 和Save。<br>\n<img src=\"http://img.blog.csdn.net/20180320180250524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n按照下面的图示，在Excute Shell和构建后操作部分写上对应的配置信息，即可。<br>\n<img src=\"http://img.blog.csdn.net/20180320182135772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n这样，我们的Jenkins Job执行完测试用例时候，将在Job的主页面上看到Allure Report图标，点击进去就看到了Allure Report报告。<br>\n<img src=\"http://img.blog.csdn.net/20180320182403557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>团队内部可能不同项目使用的测试框架不一样，每个测试框架生成的测试报告也不一样。但由于Allure报告支持很多测试框架，通过Allure可以生成格式一致的测试报告，这就对外提供格式一致的测试报告提供了方便。<br>\n建议：团队内部都采用Allure生成测试报告。<br>\n由于团队内部有的项目采用的Java+TestNG的测试架构，后面有时间，我将会介绍一下如何在TestNG框架如何集成Allure。</p>\n<h2 id=\"测试报告管理平台\">测试报告管理平台</h2>\n<p>我们希望能够把历次的测试报告进行存档和保留，方便以后查看或者对软件的质量进行度量。<br>\n下面我们就来基于Django REST framework和Vue来实现测试报告的展示和管理平台</p>\n<h3 id=\"测试报告元数据\">测试报告元数据</h3>\n<p>用pytest-json-report可以获得测试报告的生成时间、测试的结果、测试执行时间、每条测试用例的结果以及测试用例失败的原因。</p>\n<h3 id=\"测试报告静态网页\">测试报告静态网页</h3>\n<p>通过接口上传到文件服务器</p>\n<h3 id=\"编写前端页面\">编写前端页面</h3>\n<p>Vue</p>\n<h3 id=\"用nginx做反向代理\">用Nginx做反向代理</h3>\n<p>根据location代理到文件服务器</p>\n<h3 id=\"部署\">部署</h3>\n<h2 id=\"总结\">总结</h2>\n<p>总结前面的实践，展望：自动生成BUG候选列表，与JIRA对接。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>对于软件测试来说，测试报告是非常重要的工作产出。一个漂亮、清晰、格式规范的测试报告，不仅能够方便定位缺陷的位置，也方便开发人员和测试人员进行沟通。</p>\n</blockquote>\n<h2>自动化测试报告应该包含哪些内容</h2>\n<p>自动化测试报告应该自动化测试用例执行完成后自动生成的。我认为，一份完整的自动化测试报告应该包含以下几个方面：</p>\n<ul>\n<li><em>测试总体结论。</em> 用来标识本次测试是通过还是失败。</li>\n<li><em>测试概要信息。</em> 用来统计本次测试通过的用例的数量、失败的用例数量、Skipped的用例数量等。</li>\n<li><em>测试用例的执行结果。</em> 用来表示每条自动化测试用例是通过还是失败，如果失败，测试用例具体失败在哪一行。</li>\n<li><em>测试执行时长。</em> 表示本次测试花了多长时间。</li>\n<li><em>测试环境信息。</em> 表示本次测试相关的测试配置和测试环境。</li>\n</ul>\n<p>本篇文章将介绍如何使用开源的测试报告生成框架Allure生成规范、格式统一、美观的测试报告。<br>\n通过这篇文章的介绍，你将能够：</p>\n<ul>\n<li>将Allure与Pytest测试框架相结合；</li>\n<li>定制美观的测试报告；</li>\n<li>生成和查看Allure格式的测试报告；</li>\n<li>对所有的自动化测试报告进行统一管理。</li>\n</ul>\n<h2>安装Allure及Pytest插件</h2>\n<p><a href=\"http://allure.qatools.ru/\" target=\"_blank\" rel=\"noopener\">Allure</a>是一款非常轻量级并且非常灵活的开源测试报告生成框架。 它支持绝大多数测试框架， 例如TestNG、Pytest、JUint等。它简单易用，易于集成。下面就Pytest如何与Allure集成做详细介绍。<br>\n安装Allure</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install allure</span><br></pre></td></tr></table></figure>\n<p>Pytest是Python的单元测试框架，非常方便和易用。强烈推荐对于用Python进行测试工作的小伙伴使用这个测试框架，相比与Python自带的UnitTest好用太多太多。后面我将用一整篇文章介绍Pytest测试框架。今天我们主要是介绍如何将测试报告生成工具Allure集成到Pytest中。</p>\n<p><a href=\"https://pypi.org/project/allure-pytest/\" target=\"_blank\" rel=\"noopener\">allure-pytest</a>是Pytest的Allure插件，通过它可以生成Allure所需要的用于生成测试报告的数据。安装方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install allure-pytest</span><br></pre></td></tr></table></figure>\n<p>这样有关测试报告用到的库都已经安装好了。接下来我们来定制我们的测试报告吧。</p>\n<h2>定制测试报告内容</h2>\n<p>pytest-allure-adaptor官网中详细介绍了pytest-allure-adaptor所具有的功能。本篇文章不会再翻译一遍，而是从实际入手，给大家介绍如何将其应用到自己的框架中。<br>\n为了使用Allure生成报告，需要在conftest.py和测试脚本中加入Allure特性。</p>\n<p>首先，conftest.py中可以通过allure.environment方法将测试环境的信息输出到报告中，比如将测试时用的host和测试用的browser添加到测试报告中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># coding=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">import pytest</span><br><span class=\"line\">import allure</span><br><span class=\"line\">import yaml</span><br><span class=\"line\"></span><br><span class=\"line\">@pytest.fixture(scope=&quot;session&quot;, autouse=True)</span><br><span class=\"line\">def env(request):</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    Parse env config info</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    root_dir = request.config.rootdir</span><br><span class=\"line\">    config_path = &apos;&#123;0&#125;/config/env_config.yml&apos;.format(root_dir)</span><br><span class=\"line\">    with open(config_path) as f:</span><br><span class=\"line\">        env_config = yaml.load(f) # 读取配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">    allure.environment(host=env_config[&apos;host&apos;][&apos;domain&apos;]) # 测试报告中展示host</span><br><span class=\"line\">    allure.environment(browser=env_config[&apos;host&apos;][&apos;browser&apos;]) # 测试报告中展示browser</span><br><span class=\"line\"></span><br><span class=\"line\">    return env_config</span><br></pre></td></tr></table></figure>\n<p>接着，在测试脚本中，添加allure特性，直接看下面的脚本，我通过在脚本中添加注释的方式给大家解释allure特性的用途。比如测试脚本是test_shopping_trolley.py：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># coding=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">import pytest</span><br><span class=\"line\">import allure</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@allure.feature(&apos;购物车功能&apos;)  # feature定义功能</span><br><span class=\"line\">class TestShoppingTrolley(object):</span><br><span class=\"line\">    @allure.story(&apos;加入购物车&apos;)  # story定义用户场景</span><br><span class=\"line\">    def test_add_shopping_trolley(self):</span><br><span class=\"line\">        login(&apos;刘春明&apos;, &apos;密码&apos;)  # 调用“步骤函数”</span><br><span class=\"line\">        with allure.step(&quot;浏览商品&quot;):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤2</span><br><span class=\"line\">            allure.attach(&apos;商品1&apos;, &apos;刘春明&apos;)  # attach可以打印一些附加信息</span><br><span class=\"line\">            allure.attach(&apos;商品2&apos;, &apos;liuchunming&apos;)</span><br><span class=\"line\">        with allure.step(&quot;点击商品&quot;):  # 将一个测试用例分成几个步骤，将步骤打印到测试报告中，步骤3</span><br><span class=\"line\">            pass</span><br><span class=\"line\">        with allure.step(&quot;校验结果&quot;):</span><br><span class=\"line\">            allure.attach(&apos;期望结果&apos;, &apos;添加购物车成功&apos;)</span><br><span class=\"line\">            allure.attach(&apos;实际结果&apos;, &apos;添加购物车失败&apos;)</span><br><span class=\"line\">            assert &apos;success&apos; == &apos;failed&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    @allure.story(&apos;修改购物车&apos;)</span><br><span class=\"line\">    def test_edit_shopping_trolley(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">    @pytest.mark.skipif(reason=&apos;本次不执行&apos;)</span><br><span class=\"line\">    @allure.story(&apos;删除购物车&apos;)</span><br><span class=\"line\">    def test_delete_shopping_trolley(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@allure.step(&apos;用户登录&apos;)  # 还可以将一个函数作为一个步骤，调用此函数时，报告中输出一个步骤，步骤名字通常是函数名，我把这样的函数叫“步骤函数”</span><br><span class=\"line\">def login(user, pwd):</span><br><span class=\"line\">    print(user, pwd)</span><br></pre></td></tr></table></figure>\n<p>上面使用了Allure的几个特性：</p>\n<ul>\n<li>@allure.feature # 用于定义被测试的功能，被测产品的需求点</li>\n<li>@allure.story # 用于定义被测功能的用户场景，即子功能点</li>\n<li>with allure.step # 用于将一个测试用例，分成几个步骤在报告中输出</li>\n<li>allure.attach # 用于向测试报告中输入一些附加的信息，通常是一些测试数据信息</li>\n<li>@allure.step # 用于将一些通用的函数作为测试步骤输出到报告，调用此函数的地方会向报告中输出步骤</li>\n<li>allure.environment # pytest暂不支持</li>\n</ul>\n<h2>生成Allure测试报告</h2>\n<h3>生成报告原始数据</h3>\n<p>测试用例中添加了Allure特性之后，在执行测试的时候需要先生成Allure报告所需要的测试结果数据。在py.test执行测试的时候，指定–alluredir选项及测试数据保存的目录即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ py.test test/ --alluredir ./result/</span><br></pre></td></tr></table></figure>\n<p>另外，还可以执行指定features或者stories执行一部分测试用例，比如执行‘购物车功能’下的‘加入购物车’子功能的测试用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ py.test test/ --allure_features=&apos;购物车功能&apos; --allure_stories=&apos;加入购物车&apos; --alluredir ./result/</span><br></pre></td></tr></table></figure>\n<h3>生成allure格式测试报告</h3>\n<p>./result/中保存了测试结果数据。接着，执行利用上面命令产生的测试结果数据./result/生成Allure测试报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> allure generate ./result/ -o ./report/ --clean</span><br></pre></td></tr></table></figure>\n<p>可以通过下面的命令打开测试报告：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ allure open -h 127.0.0.1 -p 8083 ./report/</span><br></pre></td></tr></table></figure>\n<p>在浏览器打开http://127.0.0.1:8083网页，展示测试报告。</p>\n<h2>测试报告解读</h2>\n<p>打开生成的测试报告后，浏览器被自动调起，展示测试报告。下面我们分别看看测试报告的几个页面。</p>\n<ol>\n<li>首页<br>\n<img src=\"http://img.blog.csdn.net/20180320200100881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n首页中展示了本次测试的测试用例数量，成功用例、失败用例、跳过用例的比例，测试环境信息，SUITES，FEATURES BY STORIES等基本信息，当与Jenkins做了持续置成后，TREND区域还将显示，历次测试的通过情况。<br>\n首页的左边栏，还从不同的维度展示测试报告的其他信息，大家可以自己点进去看看。</li>\n<li>Behaviors<br>\n接下来，我们点击一下FEATURES BY STORIES，将进入Behaviors页面，这个页面按照FEATURES和 STORIES展示测试用例的执行结果：<br>\n<img src=\"http://img.blog.csdn.net/20180320200600472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n从这个页面可以看到“购物车功能”这个FEATURES包含的三个STORIES的测试用例执行情况。</li>\n<li>Suites<br>\nAllure测试报告将每一个测试脚本，作为一个Suite。在首页点击Suites区域下面的任何一条Suite，都将进入Suites页面。<br>\n<img src=\"http://img.blog.csdn.net/20180320201059219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n这个页面，将脚本的目录结果展示本次所有的测试用例执行情况。</li>\n<li>测试用例页面<br>\n在Suites页面上点击任何一条测试用例，Suites页面的右侧将展示这条用例的详细执行情况。<br>\n<img src=\"http://img.blog.csdn.net/20180320201409629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n从这个页面可以看到测试用例执行的每一个步骤，以及每个步骤的执行结果。测试用例为什么失败，这里一目了然。</li>\n</ol>\n<h3>利用Jenkins生成测试报告</h3>\n<p>前面我们通过命令行方法生成测试报告，通常是在本地调试时候使用。而真正的自动化测试一定是与持续集成相结合的，比如利用Jenkins进行测试的自动执行。<br>\n要想在持续集成中自动生成测试报告，首先需要给Jenkins安装Allure Plugin。在Jenkins的插件管理页面，搜索“allure”，在搜索结果页，选择“Allure Jenkins Plugin”进行安装。<br>\n安装完成之后重启一下Jenkins。<br>\n在Jenkins的“全局工具管理”页面，找到Allure Commandline模块进行安装：<br>\n<img src=\"http://img.blog.csdn.net/20180320175830037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n点击后，弹出下面的页面，输入Allure的命令别名和版本后，点击Apply 和Save。<br>\n<img src=\"http://img.blog.csdn.net/20180320180250524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n按照下面的图示，在Excute Shell和构建后操作部分写上对应的配置信息，即可。<br>\n<img src=\"http://img.blog.csdn.net/20180320182135772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n这样，我们的Jenkins Job执行完测试用例时候，将在Job的主页面上看到Allure Report图标，点击进去就看到了Allure Report报告。<br>\n<img src=\"http://img.blog.csdn.net/20180320182403557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>团队内部可能不同项目使用的测试框架不一样，每个测试框架生成的测试报告也不一样。但由于Allure报告支持很多测试框架，通过Allure可以生成格式一致的测试报告，这就对外提供格式一致的测试报告提供了方便。<br>\n建议：团队内部都采用Allure生成测试报告。<br>\n由于团队内部有的项目采用的Java+TestNG的测试架构，后面有时间，我将会介绍一下如何在TestNG框架如何集成Allure。</p>\n<h2>测试报告管理平台</h2>\n<p>我们希望能够把历次的测试报告进行存档和保留，方便以后查看或者对软件的质量进行度量。<br>\n下面我们就来基于Django REST framework和Vue来实现测试报告的展示和管理平台</p>\n<h3>测试报告元数据</h3>\n<p>用pytest-json-report可以获得测试报告的生成时间、测试的结果、测试执行时间、每条测试用例的结果以及测试用例失败的原因。</p>\n<h3>测试报告静态网页</h3>\n<p>通过接口上传到文件服务器</p>\n<h3>编写前端页面</h3>\n<p>Vue</p>\n<h3>用Nginx做反向代理</h3>\n<p>根据location代理到文件服务器</p>\n<h3>部署</h3>\n<h2>总结</h2>\n<p>总结前面的实践，展望：自动生成BUG候选列表，与JIRA对接。</p>\n"},{"title":"谈一谈软件测试中的测试数据准备","catalog":true,"toc_nav_num":true,"date":"2019-04-16T11:51:24.000Z","subtitle":"测试数据准备方法以及未来的发展方向","header-img":"/img/article_header/bullon.jpg","catagories":["软件测试"],"_content":"\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据平台\"从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。\n\n### 提供真实数据\n下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。\n\n比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。\n\n首先，使用pipenv创建虚拟环境，安装好Flask框架。\n```shell\nmkdir flasky\ncd flasky\npipenv --python 3.6\npipenv install flask\n```\n下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。\n```python\nimport time\nimport uuid\nimport requests\nfrom flasgger import swag_from\nfrom flask import Flask, jsonify,request\n\napp = Flask(__name__)\n\n@app.route('/api/1/vid', methods=['POST'])\n@swag_from('./register_vehicle.yml')\ndef register_vehicle():\n    args = request.args.to_dict()\n    if 'vin' not in args:\n        return jsonify(result_code=\"failed\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       debug_msg=\"vin is required\",\n                       data={})\n    payload = {\n        \"vin\": args.get(\"vin\", \"chunming12345678997\"),\n        \"color\": args.get(\"color\", \"blue\"),\n        \"plate_number\": args.get(\"plate_number\", \"京D12345\"),\n        \"model\": args.get(\"model\", \"ES8\"),\n        \"misc\": args.get(\"misc\", \"demo\")\n    }\n\n    r = requests.request(\"POST\", \"https://example.com/api/1/in/vehicle/profile\", data=payload)\n    response = jsonify(result_code=\"success\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       data=r.json())\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。\n\n### 提供Mock数据\n什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。\n\n其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：\n```python\nfrom flask import jsonify, Flask\nfrom flasgger import swag_from\nimport time\nimport uuid\napp = Flask(__name__)\n\nack = {\n    \"data\": {\n        \"ack\": 1\n    },\n    \"request_id\":str(uuid.uuid1()),\n    \"server_time\":int(time.time()),\n    \"result_code\":\"success\"\n}\n\n@app.route(\"/ack\", methods=['GET'])\n@swag_from('./register_vehicle.yml')\ndef get_ack():\n    return jsonify(ack)\n```\n通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。","source":"_posts/谈一谈软件测试中的测试数据准备.md","raw":"---\ntitle: \"谈一谈软件测试中的测试数据准备\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-16 19:51:24\nsubtitle: \"测试数据准备方法以及未来的发展方向\"\nheader-img: \"/img/article_header/bullon.jpg\"\ntags:\n- 软件测试\ncatagories:\n- 软件测试\n---\n\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据平台\"从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。\n\n### 提供真实数据\n下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。\n\n比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。\n\n首先，使用pipenv创建虚拟环境，安装好Flask框架。\n```shell\nmkdir flasky\ncd flasky\npipenv --python 3.6\npipenv install flask\n```\n下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。\n```python\nimport time\nimport uuid\nimport requests\nfrom flasgger import swag_from\nfrom flask import Flask, jsonify,request\n\napp = Flask(__name__)\n\n@app.route('/api/1/vid', methods=['POST'])\n@swag_from('./register_vehicle.yml')\ndef register_vehicle():\n    args = request.args.to_dict()\n    if 'vin' not in args:\n        return jsonify(result_code=\"failed\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       debug_msg=\"vin is required\",\n                       data={})\n    payload = {\n        \"vin\": args.get(\"vin\", \"chunming12345678997\"),\n        \"color\": args.get(\"color\", \"blue\"),\n        \"plate_number\": args.get(\"plate_number\", \"京D12345\"),\n        \"model\": args.get(\"model\", \"ES8\"),\n        \"misc\": args.get(\"misc\", \"demo\")\n    }\n\n    r = requests.request(\"POST\", \"https://example.com/api/1/in/vehicle/profile\", data=payload)\n    response = jsonify(result_code=\"success\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       data=r.json())\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。\n\n### 提供Mock数据\n什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。\n\n其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：\n```python\nfrom flask import jsonify, Flask\nfrom flasgger import swag_from\nimport time\nimport uuid\napp = Flask(__name__)\n\nack = {\n    \"data\": {\n        \"ack\": 1\n    },\n    \"request_id\":str(uuid.uuid1()),\n    \"server_time\":int(time.time()),\n    \"result_code\":\"success\"\n}\n\n@app.route(\"/ack\", methods=['GET'])\n@swag_from('./register_vehicle.yml')\ndef get_ack():\n    return jsonify(ack)\n```\n通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。","slug":"谈一谈软件测试中的测试数据准备","published":1,"updated":"2019-04-18T07:04:30.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumd63f20007xh9vfh3r5r5c","content":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2 id=\"常见的测试数据准备方法\">常见的测试数据准备方法</h2>\n<p>我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3 id=\"基于gui准备测试数据\">基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3 id=\"基于api准备测试数据\">基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3 id=\"基于db准备测试数据\">基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3 id=\"基于mq准备测试数据\">基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3 id=\"基于第三方库准备测试数据\">基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3 id=\"综合运用上述方法准备测试数据\">综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2 id=\"准备测试数据的时机\">准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3 id=\"实时创建on-the-fly\">实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3 id=\"提前准备out-of-box\">提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2 id=\"构造测试数据的痛点及应对\">构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3 id=\"调用封装函数的复杂性\">调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3 id=\"封装函数的版本管理\">封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2 id=\"统一测试数据生成平台\">统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据平台&quot;从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。</p>\n<h3 id=\"提供真实数据\">提供真实数据</h3>\n<p>下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。</p>\n<p>比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。</p>\n<p>首先，使用pipenv创建虚拟环境，安装好Flask框架。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flasky</span><br><span class=\"line\">cd flasky</span><br><span class=\"line\">pipenv --python 3.6</span><br><span class=\"line\">pipenv install flask</span><br></pre></td></tr></table></figure>\n<p>下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify,request</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/api/1/vid', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register_vehicle</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    args = request.args.to_dict()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">'vin'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(result_code=<span class=\"string\">\"failed\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       debug_msg=<span class=\"string\">\"vin is required\"</span>,</span><br><span class=\"line\">                       data=&#123;&#125;)</span><br><span class=\"line\">    payload = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"vin\"</span>: args.get(<span class=\"string\">\"vin\"</span>, <span class=\"string\">\"chunming12345678997\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: args.get(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"blue\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"plate_number\"</span>: args.get(<span class=\"string\">\"plate_number\"</span>, <span class=\"string\">\"京D12345\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"model\"</span>: args.get(<span class=\"string\">\"model\"</span>, <span class=\"string\">\"ES8\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"misc\"</span>: args.get(<span class=\"string\">\"misc\"</span>, <span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r = requests.request(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"https://example.com/api/1/in/vehicle/profile\"</span>, data=payload)</span><br><span class=\"line\">    response = jsonify(result_code=<span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       data=r.json())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。</p>\n<h3 id=\"提供mock数据\">提供Mock数据</h3>\n<p>什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。</p>\n<p>其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> jsonify, Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">ack = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ack\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"request_id\"</span>:str(uuid.uuid1()),</span><br><span class=\"line\">    <span class=\"string\">\"server_time\"</span>:int(time.time()),</span><br><span class=\"line\">    <span class=\"string\">\"result_code\"</span>:<span class=\"string\">\"success\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/ack\", methods=['GET'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ack</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(ack)</span><br></pre></td></tr></table></figure>\n<p>通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2>常见的测试数据准备方法</h2>\n<p>我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3>基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3>基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3>基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3>基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3>基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3>综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2>准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3>实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3>提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2>构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3>调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3>封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2>统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据平台&quot;从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。</p>\n<h3>提供真实数据</h3>\n<p>下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。</p>\n<p>比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。</p>\n<p>首先，使用pipenv创建虚拟环境，安装好Flask框架。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flasky</span><br><span class=\"line\">cd flasky</span><br><span class=\"line\">pipenv --python 3.6</span><br><span class=\"line\">pipenv install flask</span><br></pre></td></tr></table></figure>\n<p>下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify,request</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/api/1/vid', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register_vehicle</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    args = request.args.to_dict()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">'vin'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(result_code=<span class=\"string\">\"failed\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       debug_msg=<span class=\"string\">\"vin is required\"</span>,</span><br><span class=\"line\">                       data=&#123;&#125;)</span><br><span class=\"line\">    payload = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"vin\"</span>: args.get(<span class=\"string\">\"vin\"</span>, <span class=\"string\">\"chunming12345678997\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: args.get(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"blue\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"plate_number\"</span>: args.get(<span class=\"string\">\"plate_number\"</span>, <span class=\"string\">\"京D12345\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"model\"</span>: args.get(<span class=\"string\">\"model\"</span>, <span class=\"string\">\"ES8\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"misc\"</span>: args.get(<span class=\"string\">\"misc\"</span>, <span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r = requests.request(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"https://example.com/api/1/in/vehicle/profile\"</span>, data=payload)</span><br><span class=\"line\">    response = jsonify(result_code=<span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       data=r.json())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。</p>\n<h3>提供Mock数据</h3>\n<p>什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。</p>\n<p>其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> jsonify, Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">ack = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ack\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"request_id\"</span>:str(uuid.uuid1()),</span><br><span class=\"line\">    <span class=\"string\">\"server_time\"</span>:int(time.time()),</span><br><span class=\"line\">    <span class=\"string\">\"result_code\"</span>:<span class=\"string\">\"success\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/ack\", methods=['GET'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ack</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(ack)</span><br></pre></td></tr></table></figure>\n<p>通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。</p>\n<h2>总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjumd63ev0003xh9vj4hrvckm","tag_id":"cjumd63f00006xh9vj8ilpz97","_id":"cjumd63f50009xh9vo710vz7h"},{"post_id":"cjumd63ey0005xh9vxjyach16","tag_id":"cjumd63f40008xh9v6ekfi6nj","_id":"cjumd63f8000bxh9vi3fc2c7e"},{"post_id":"cjumd63f20007xh9vfh3r5r5c","tag_id":"cjumd63f40008xh9v6ekfi6nj","_id":"cjumd63fa000cxh9vzcaj4svu"},{"post_id":"cjumd63eq0001xh9vybo0en8i","tag_id":"cjumd63f40008xh9v6ekfi6nj","_id":"cjumds54b00006d9vq1cue1js"},{"post_id":"cjumd63ey0005xh9vxjyach16","tag_id":"cjumecggi0000439viwoi588q","_id":"cjumecggn0001439vtsfddg7h"},{"post_id":"cjumd63eq0001xh9vybo0en8i","tag_id":"cjumecgik0002439v17kzbp1b","_id":"cjumecgil0004439v4tup2x79"},{"post_id":"cjumd63eq0001xh9vybo0en8i","tag_id":"cjumecgil0003439vte3aedef","_id":"cjumecgim0005439vnztkv5yr"}],"Tag":[{"name":"Hexo","_id":"cjumd63f00006xh9vj8ilpz97"},{"name":"软件测试","_id":"cjumd63f40008xh9v6ekfi6nj"},{"name":"Allure","_id":"cjumecggi0000439viwoi588q"},{"name":"Kubernates","_id":"cjumecgik0002439v17kzbp1b"},{"name":"Docker","_id":"cjumecgil0003439vte3aedef"}]}}